---
title: "Employment as managers rates by race"
author: "Alicia Vo"
date: "2025-07-10"
output: html_document
---
# Load packages, connect to postgres, get spatial data
```{r}
# Install packages if not already installed
packages <- c("data.table", "readxl", "stringr", "dplyr", "RPostgres", "dbplyr", "srvyr", "tidycensus", "rpostgis",  "tidyr", "here", "sf", "usethis","purrr") 

install_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(install_packages) > 0) {
  install.packages(install_packages)
} else {
  print("All required packages are already installed.")
}

for(pkg in packages){
  library(pkg, character.only = TRUE)
}

options(scipen = 100) # disable scientific notation

# Connect to postgres 
source("W:\\RDA Team\\R\\credentials_source.R")
con_shared<-connect_to_db("rda_shared_data")
con<-connect_to_db("cancel_the_contract")

# Grab SPA-tract xwalk so that we can get all tracts within SPA 1 which we are using as our AV geography. Census tracts are 2023.
spa <- dbGetQuery(con_shared, "SELECT * FROM crosswalks.lacounty_health_district_spa_tract_2022")%>%
  filter(spa_num==1)

# Pull out the tracts for spa 1
ct_av <- spa$ct_geoid

# Get crosswalk of tracts to PUMAs (uses 2020 PUMA data and 2020 tract data for CA)
xwalk <- dbGetQuery(con_shared, "SELECT *FROM crosswalks.puma_tract_xwalk_2020")

# Filter crosswalk for AV tracts only
xwalk_puma_ct <- xwalk %>% 
  filter(ct_geoid %in% ct_av)

# Create list of PUMA ids in AV (only 3 PUMAs in AV)
puma_av <- unique(xwalk_puma_ct$puma_geoid)
puma_av <- paste0("06",puma_av)

# define variables used throughout - update each year
curr_yr <- 2023 
start_yr <- curr_yr - 4  # autogenerate start yr of 5yr estimates
```

# Get PUMS Data 
```{r}
# Data Dictionary: https://www2.census.gov/programs-surveys/acs/tech_docs/pums/data_dict/PUMS_Data_Dictionary_2023.pdf
# path where my data lives (not pulling pums data from the postgres db, takes too long to run calcs that way) 
root <- paste0("W:/Data/Demographics/PUMS/CA_", start_yr, "_", curr_yr, "/")
# Load ONLY the PUMS columns needed for this indicator
cols <- colnames(fread(paste0(root, "psam_p06.csv"), nrows=0)) # get all PUMS cols 
cols_wts <- grep("^PWGTP*", cols, value = TRUE)                # filter for PUMS weight colnames

ppl <- fread(paste0(root, "psam_p06.csv"), header = TRUE, data.table = FALSE, 
             select = c(cols_wts, "AGEP", "ESR", "SCH", "SOCP", "PUMA", "ANC1P", "ANC2P", "HISP", "RAC1P","RACAIAN", "RACPI", "RACNH"),
             colClasses = list(character = c("ESR", "SCH", "SOCP", "PUMA", "ANC1P", "ANC2P", "HISP", "RAC1P", "RACAIAN", "RACPI", "RACNH")))

# Add state_geoid to ppl, add state_geoid to PUMA id, so it aligns with crosswalks.puma_county_2020
ppl$state_geoid <- "06"
ppl$puma_id <- paste0(ppl$state_geoid, ppl$PUMA)


# create list of replicate weights
repwlist = rep(paste0("PWGTP", 1:80))

# save copy of original data
orig_data <- ppl

# redo analysis
ppl <- orig_data

# Filter for AV PUMAS
ppl <- ppl %>%
  filter(puma_id %in% puma_av)

# QA check the pumas remaining in the ppl table--looks good
table(ppl$puma_id)

```

# Reclassify Race/Ethnicity
```{r}
source("W:/RDA Team/R/Github/RDA Functions/main/RDA-Functions/PUMS_Functions_new.R")    

# latino includes all races. AIAN is AIAN alone/combo latino/non-latino, NHPI is alone/combo latino/non-latino, SWANA includes all races and latino/non-latino
ppl <- race_reclass(ppl, start_yr, curr_yr)

table(ppl$race)
table(ppl$aian)
table(ppl$latino)
table(ppl$swana)
table(ppl$pacisl)

# create columns nh_aian, nh_nhpi
ppl_nh <- ppl %>%
  mutate(nh_aian = ifelse(aian=="aian" & latino=="not latino", "nh_aian", "not nh_aian"),
         nh_nhpi = ifelse(pacisl=="pacisl" & latino=="not latino", "nh_nhpi", "not nh_nhpi"))

# QA just check the recoding looks the way it should --- looks good
nh_qa<-ppl_nh%>%select(race, aian, nh_aian, pacisl, nh_nhpi, latino)

```

## Classify SSWANA
```{r}
# I need columns nh_asian_wo_sa and sswana, which I can make once I create a south_asian column. 

# reference from av_race_pop.R
soasian_list<-list("Asian Indian", "Bangladeshi", "Bhutanese","Maldivian","Nepalese","Pakistani","Sikh","Sindhi","Sri Lankan","Other South Asian")

# read in PUMS data dictionary at the row where ANC1P starts and filter for south asian ancestries
pums_dict <- read.csv("W:/Project/RJS/CTC/Data/PUMS_Data_Dictionary_2019-2023.csv", skip=1808)%>%
  rename(ancestry = Austrian, code = X003) %>%
  select(ancestry, code) %>% 
  filter(ancestry %in% soasian_list)

# create south asian column
ppl_soasian <- ppl_nh %>%
  mutate(soasian = ifelse(ANC1P %in% pums_dict$code | ANC2P %in% pums_dict$code, "south asian", "not south asian"))

# QA just examine results to make sure it worked correctly

soasian_qa<-ppl_soasian%>%select(ANC1P, ANC2P, race, latino, soasian)

check<-ppl_soasian%>%filter((ANC1P %in% pums_dict$code | ANC2P %in% pums_dict$code) & soasian=="not south asian")%>%
  select(ANC1P, ANC2P, soasian) # 0 observations this is good

# qa check
qa <- ppl_soasian %>%
  select(ANC1P, ANC2P, soasian) %>%
  filter(soasian == "south asian") %>%
  left_join(pums_dict, by = c("ANC1P"="code")) %>%
  left_join(pums_dict, by = c("ANC2P"="code"))
table(qa$ancestry.x)
table(qa$ancestry.y)

# create columns nh_asian_wo_sa and sswana
ppl_sswana <- ppl_soasian %>%
  mutate(nh_asian_wo_sa = ifelse(race=="nh_asian" & soasian=="not south asian", "nh_asian_wo_sa", "not nh_asian_wo_sa"),
        sswana = ifelse(swana=="swana" | soasian=="south asian", "sswana", "not sswana"))

# QA examine the recoding results

sum(is.na(ppl_sswana$nh_asian_wo_sa)) # there are 364 NAs

# examine NAs

sswana_na<-ppl_sswana%>%filter(is.na(nh_asian_wo_sa))%>%
  select(race, latino, soasian, nh_asian_wo_sa, swana, sswana) # makes sense because all of these have NA for the race column

# now QA the rest

sswana_qa<-ppl_sswana%>%
  select(race, latino, soasian, nh_asian_wo_sa, swana, sswana)

ppl <- ppl_sswana
```

# Define Officials and Managers
```{r}
# For this project we only wanted data for people in labor market - ages between 18 and 64
ppl <- ppl[ppl$AGEP >= 18 & ppl$AGEP <= 64 , ]

## Tag people who are officials or managers: SOCP value starts with "11" 
###### See p110 in W:\Data\Demographics\PUMS\CA_2019_2023\PUMS_Data_Dictionary_2023.pdf
ppl$offmgr <- 
  case_when(
    grepl('^11', ppl$SOCP) ~ as.integer(1),
    TRUE ~ as.integer(0))

# rate of managers 64.8 per 1000 people, common sense check on https://www.racecounts.org/issue/economic/
sum(ppl$offmgr) / nrow(ppl) * 1000
```

## Filter for managers who are currently in the labor force 
Code for labor force status: ESR on p56 of PUMS_Data_Dictionary_2023.pdf https://www2.census.gov/programs-surveys/acs/tech_docs/pums/data_dict/PUMS_Data_Dictionary_2023.pdf

ESR Character 1
Employment status recode
b .N/A (less than 16 years old)
1 .Civilian employed, at work
2 .Civilian employed, with a job but not at work
3 .Unemployed
4 .Armed forces, at work
5 .Armed forces, with a job but not at work
6 .Not in labor force
```{r}
table(ppl$ESR, useNA = "always")

# NOTE: 'This includes 4-Armed forces, at work' and '5-Armed forces, with a job but not at work'. It excludes '6-Not in labor force'.
ppl$emply <- as.factor(ifelse(ppl$ESR %in% c(1, 2, 3, 4, 5), "in labor force", "not in labor force")) 
# 8526 people in labor force
sum(ppl$emply=="in labor force")

ppl <- filter(ppl, emply=='in labor force')

## Factor for Officials & Managers
ppl$officials <- ifelse(ppl$offmgr == 1, "officials", "not official")
ppl$officials <- as.factor(ppl$officials)

# rate of managers is now 89.3 per 1000 people
sum(ppl$officials == "officials") / nrow(ppl) * 1000
```
# CALC PUMA ESTIMATES/CVS ETC, code adapted from RC function calc_pums()
```{r}
# Create survey design object
ppl_calc <- ppl %>%               
  as_survey_rep(
    variables = c(race, aian, latino, swana, pacisl, nh_aian, nh_nhpi, nh_asian_wo_sa, sswana, officials),   # select grouping variables
    weights = 'PWGTP',                      # PWGTP for person-level (psam_p06.csv) script
    repweights = repwlist,                  # list of replicate weights
    combined_weights = TRUE,                # tells the function that replicate weights are included in the data
    mse =TRUE,                              # tells the function to calc mse
    type="other",                           # statistical method
    scale=4/80,                             # scaling set by ACS
    rscale=rep(1,80))                        # setting specific to ACS-scaling

# Calculate manager rate of AV total
row_total <- ppl_calc %>% 
  group_by(officials) %>%
  summarise(
    race = "total",
    count = survey_total(na.rm = TRUE),    # Survey weighted total, numerator  
    rate = survey_mean() * 100,            # Survey weighted rate per 100
  ) %>%
  mutate(rate_moe  = rate_se * 1.645,
          rate_cv   = (rate_se / rate) * 100,
          count_moe = count_se * 1.645,
          count_cv  = (count_se / count) * 100) %>%
  filter(officials=="officials")  %>%
  select(-officials)

# function to calculate rates by racial groups
calc_manager_rate <- function(data, group_var) {
  # Capture the grouping variable as a symbol
  group_var_sym <- rlang::ensym(group_var)

  data %>%
    # Group by the specified variable and the "officials" column
    group_by(!!group_var_sym, officials) %>%
    
    # Calculate the weighted count and rate (per 100 people)
    summarise(
      count = survey_total(na.rm = TRUE),  # Weighted total
      rate = survey_mean() * 100,          # Weighted rate per 100
      .groups = "drop"
    ) %>%
    mutate(rate_moe  = rate_se * 1.645,
          rate_cv   = (rate_se / rate) * 100,
          count_moe = count_se * 1.645,
          count_cv  = (count_se / count) * 100) %>%
    # Keep only rows where role is "officials" and group value is not NA
    filter(officials == "officials", !is.na(!!group_var_sym)) %>%
    
    # Rename the grouping variable to "race"
    rename(race = !!group_var_sym) %>%
    
    # Drop rows where the "race" value includes "not" (e.g., "not specified")
    filter(!grepl("not", race, ignore.case = TRUE)) %>%
    select(-officials)
}

# list of all the racial groups
variables = c("race", "aian", "latino", "swana", "pacisl", "nh_aian", "nh_nhpi", "nh_asian_wo_sa", "sswana")  
# call calc_manager_rate() on all the racial groups we want to create the final table
manager_table <- variables %>%
  map(~ calc_manager_rate(ppl_calc, !!sym(.x))) %>%
  bind_rows(row_total) %>%
  arrange(rate) %>%
  mutate(geography = "Antelope Valley") %>%
  select(geography, race, count, count_se, count_moe, count_cv, everything())
```

# Send table to postgres
```{r}
# Write table with metadata
table_name <- "av_managers_by_race"
schema <- "data"
indicator <- "A table with the rates of managers by racial group in the Antelope Valley. Note that only people between the ages of 18-64 who are currently in the labor force are counted."
source <- "Script: W:/Project/RJS/CTC/Github/AV/cancel_the_contract/Analysis/analysis_managers.Rmd "
qa_filepath <- "See QA doc for details: W:/Project/RJS/CTC/Documentation/QA_av_managers_by_race "
table_comment <- paste0(indicator, source)
dbWriteTable(con, Id(schema, table_name), manager_table, overwrite = TRUE, row.names = FALSE)

# Comment on table and columns
column_names <- colnames(manager_table) # Get column names
column_comments <- c(
  "Geography is the Antelope Valley",
  "The racial group",
  "The weighted count of managers of the indicated racial group",
  "Standard error for count",
  "Margin of error for count",
  "CV for count",
  "The weighted rate of managers of the indicated racial group",
  "Standard error for rate",
  "Margin of error for rate",
  "CV for rate"
)

add_table_comments(con, schema, table_name, indicator, source, qa_filepath, column_names, column_comments)
```


